# 양봉업자코코
##### Tag: 구현, 그래프 이론, 그래프 탐색, 너비 우선 탐색, 깊이 우선 탐색
##### 풀이 일자: 2026년 2월 17일

## 문제 탐색하기
주어진 배열(육각형 벌집모양)을 탐색해서 최댓값을 찾기

### 해결요소
1. 주어진 육각형 배열의 방향 배열을 설정
2. DFS로 현재 진행중인 좌표와 다음 진행할 좌표 2개를 진행 -> 그래야 T 모양이 탐색 가능

## 코드 설계하기
```
// 벌집 이동에 맞춘 6각 이동
// j가 홀수 (1, 3, 5, ...)
int odd_dy[6] = { -1, 0, 1, 1, 1, 0 };
int odd_dx[6] = { 0, 1, 1, 0, -1, -1 };
// j가 짝수 (0, 2, 4, ...)
int even_dy[6] = { -1, -1, 0, 1, 0, -1 };
int even_dx[6] = { 0, 1, 1, 0, -1, -1 };

// DFS 로직
void DFS(Pos now, int honey, int block) {
	// 기저
	if (block >= 4) {
		max_honey = max(max_honey, honey);
		return;
	}

	// 재귀
	for (int d = 0; d < 6; d++) {
		// 다음 방향 좌표 설정
		int ny, nx;
		// 현재 x좌표가 짝수라면
		if (now.x % 2 == 0) {
			ny = now.y + even_dy[d];
			nx = now.x + even_dx[d];
		}
		// 현재 x좌표가 홀수라면
		else {
			ny = now.y + odd_dy[d];
			nx = now.x + odd_dx[d];
		}
		
		// 보드 경계 체크
		if (ny >= N || ny < 0 || nx >= M || nx < 0) continue;
		// 방문 여부 확인
		if (visited[ny][nx] == 1) continue;

		visited[ny][nx] = 1;
		honey += board[ny][nx];

		DFS({ ny, nx }, honey, block + 1);
		DFS(now, honey, block + 1);

		visited[ny][nx] = 0;
		honey -= board[ny][nx];
	}

}
```
### 시간 복잡도
O((NxM)^2)  
N과 M은 최대 15, 따라서 최대 연산 15^4 ~ 50,000 < 1억  
(최악) 각 칸마다 모든 칸을 순회한다고 가정

## 정답 코드
```
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;

int ans;

int N, M;
int board[16][16];
int visited[16][16];

// 벌집 이동에 맞춘 6각 이동
// j가 홀수 (1, 3, 5, ...)
int odd_dy[6] = { -1, 0, 1, 1, 1, 0 };
int odd_dx[6] = { 0, 1, 1, 0, -1, -1 };
// j가 짝수 (0, 2, 4, ...)
int even_dy[6] = { -1, -1, 0, 1, 0, -1 };
int even_dx[6] = { 0, 1, 1, 0, -1, -1 };

// 좌표 정보
struct Pos {
	int y, x;
};

int max_honey;	// 최대 벌꿀 값

struct Position {
	Pos pos;	// 탐색할 위치 좌표
	int cal;	// 현재의 꿀 모음
	int left;	// 탐색 칸 수
};

void init() {
	ans = 0; N = 0; M = 0;
	memset(board, 0, sizeof(board));
	max_honey = 0;
}
void input() {
	cin >> N >> M;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			cin >> board[i][j];
		}
	}

}

void DFS(Pos now, int honey, int block) {
	// 기저
	if (block >= 4) {
		max_honey = max(max_honey, honey);
		return;
	}

	// 재귀
	for (int d = 0; d < 6; d++) {
		// 다음 방향 좌표 설정
		int ny, nx;
		// 현재 x좌표가 짝수라면
		if (now.x % 2 == 0) {
			ny = now.y + even_dy[d];
			nx = now.x + even_dx[d];
		}
		// 현재 x좌표가 홀수라면
		else {
			ny = now.y + odd_dy[d];
			nx = now.x + odd_dx[d];
		}
		
		// 보드 경계 체크
		if (ny >= N || ny < 0 || nx >= M || nx < 0) continue;
		// 방문 여부 확인
		if (visited[ny][nx] == 1) continue;

		visited[ny][nx] = 1;
		honey += board[ny][nx];

		DFS({ ny, nx }, honey, block + 1);
		DFS(now, honey, block + 1);

		visited[ny][nx] = 0;
		honey -= board[ny][nx];
	}

}


void solve() {
	// 각 좌표에서 탐색 진행
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			// 방문 배열 초기화
			memset(visited, 0, sizeof(visited));
			
			visited[i][j] = 1;
			DFS({ i, j }, board[i][j], 1);
		}
	}

	ans = max_honey;
}

int main() {
	int T;
	cin >> T;
	for (int t = 1; t <= T; t++) {
		init();
		input();
		solve();

		cout << '#' << t << ' ' << ans << endl;
	}
	return 0;
}
```
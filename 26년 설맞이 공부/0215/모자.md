# 모자
##### Tag: Greedy, 정렬
##### 풀이 일자: 2026년 2월 15일

## 문제 탐색하기
사람이 요구하는 모자 사이즈에 맞춰 최대한 많은 사람에게 모자 주기

### 해결요소
1. 모자와 사람 수는 모두 N으로 동일
2. 사람이 요구하는 모자 크기보다 +-3 이내이면 모자 주기
3. 이중 반복문으로 사람 별 맞춤 모자 찾기

## 코드 설계하기
```
// Greedy 탐색 원리

// 오름차순 정렬
sort(human, human + N);
sort(hat, hat + N);

// 모든 사람에 대해서, 모자에 대해 탐색
for (int i = 0; i < N; i++) {
	for (int j = 0; j < N; j++) {
		if (used[j] == 1) continue;

		// 원하는 사이즈 차이가 3이내인 경우
		if (abs(human[i] - hat[j]) <= 3) {
			// 해당 모자를 사용
			used[j] = 1;
			// 착용한 사람 +1
			cnt++;
			// 다음 사람 모자 탐색
			break;
		}

	}

}

```
### 시간 복잡도
O(N^2)  
사람 수 N : 모자 수 N  
N은 최대 500  
사람 한 명이 N개의 모자를 탐색 (최악의 경우 500번 모두 탐색)  
500 x 500 = 250,000 < 1억 이므로 연산 가능  

[만약 DFS로 풀이 했을 경우]  
DFS 시간 복잡도 O(N!)  
N이 500인 경우 500! > 1억 이므로 연산 불가능!!


## 정답 코드
```
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;

int ans;

int N;			// 사람&모자 수
int human[501];	// 사람들이 원하는 모자 정보
int hat[501];	// 실제 모자 정보
int used[501];	// 모자의 사용 여부

int cnt;	// 모자를 착용한 사람의 수

// 초기화 함수
void init(){
	N = 0;
	memset(human, 0, sizeof(human));
	memset(hat, 0, sizeof(hat));
	memset(used, 0, sizeof(used));
	ans = 0;
}

// 입력 함수
void input() {
	cin >> N;
	for (int i = 0; i < N; i++) {
		cin >> human[i];
	}
	for (int i = 0; i < N; i++) {
		cin >> hat[i];
	}
}


// 풀이 함수
void solve() {
	cnt = 0;

	// 오름차순 정렬
	sort(human, human + N);
	sort(hat, hat + N);

	// 모든 사람에 대해서, 모자에 대해 탐색
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			if (used[j] == 1) continue;

			// 원하는 사이즈 차이가 3이내인 경우
			if (abs(human[i] - hat[j]) <= 3) {
				// 해당 모자를 사용
				used[j] = 1;
				// 착용한 사람 +1
				cnt++;
				// 다음 사람 모자 탐색
				break;
			}

		}

	}
	ans = cnt;
}


int main() {
	int T;
	cin >> T;
	for (int t = 1; t <= T; t++) {
		init();
		input();
		solve();

		cout << '#' << t << ' ' << ans << endl;
	}

	return 0;
}
```
# 산악구조로봇
##### Tag: BFS, Flood Fill
##### 풀이 일자: 2026년 2월 15일

## 문제 탐색하기
(0, 0) => (N-1, N-1)으로 가는 비용 최소화

### 해결요소
1. 낮은 칸으로 이동할 때는 비용 0
2. 높은 칸으로 이동할 때는 비용 차이x2
3. 같은 칸으로 이동할 때는 비용 1
4. BFS Flood Fill로 이동시 연료의 최솟값만 기록

## 코드 설계하기
```
// 핵심이 되는 BFS 함수
void bfs(Pos st) {
	// 큐 설정
	queue<Pos> q;
	q.push(st);
	// 시작지점은 연료가 0;
	fuel[st.y][st.x] = 0;

	while (!q.empty()) {
		// 현재 지점
		Pos now = q.front();
		q.pop();

		// 4방향 탐색
		for (int d = 0; d < 4; d++) {
			int ny = now.y + dy[d];
			int nx = now.x + dx[d];

			// 경계 체크
			if (ny >= N || ny < 0 || nx >= N || nx < 0) continue;

			// 다음 경로 비용 체크
			int next_cost;
			// 내리막길인 경우
			if (board[now.y][now.x] > board[ny][nx]) {
				next_cost = 0;
			}
			// 오르막길인 경우
			else if (board[now.y][now.x] < board[ny][nx]) {
				next_cost = (board[ny][nx]- board[now.y][now.x]) * 2;
			}
			// 평지인 경우
			else if (board[now.y][now.x] == board[ny][nx]) {
				next_cost = 1;
			}

			// 만약 다음 이동하는 연료 소비가, 기존의 소비보다 클 경우 pass
			if (fuel[ny][nx] <= fuel[now.y][now.x] + next_cost) continue;

			// 연료 맵을 업데이트
			fuel[ny][nx] = fuel[now.y][now.x] + next_cost;

			// 큐에 다음 목적지를 push
			q.push({ ny, nx });
		}
	}
}

```
### 시간 복잡도
O(N^4)  
NxN 보드에서 최소 비용이 발견 될 때마다 갱신됨으로 N^4  
N은 최대 30이므로 30^4 ~ 810,000 < 1억임으로 연산 가능

더욱 효율적인 연산을 원하면, 우선순위 큐를 활용!  
[이때의 시간 복잡도: O(N^2 log(N^2))]

## 정답 코드
```
#include <iostream>
#include <queue>
#include <vector>
#include <cstring>
using namespace std;

int ans;			// 정답
int N;				// 보드의 가로 세로 길이
int board[31][31];	// 보드 정보
int fuel[31][31];	// 이동하면서 담을 연료 정보

// 상 하 좌 우 방향배열
int dy[] = { -1, 1, 0, 0 };
int dx[] = { 0, 0, -1, 1 };

// 좌표 정보 구조체
struct Pos {
	int y, x;
};
// 시작점 끝점 좌표 설정
Pos st = { 0, 0 };
Pos en = { N - 1, N - 1 };

// 초기화 함수
void init(){
	// 정답, N 초기화
	ans = 0; N = 0; 

	// 보드 정보 초기화
	memset(board, 0, sizeof(board));

	// 이동 연료 정보 초기화 - 최솟값을 구할 것이라 21e8 선택
	for (int i = 0; i < 31; i++) {
		for (int j = 0; j < 31; j++) {
			fuel[i][j] = 21e8;
		}
	}

}

// 입력 함수
void input() {
	// 가로 세로 길이 인풋
	cin >> N;

	// 보드 정보 인풋
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cin >> board[i][j];
		}
	}
}


void bfs(Pos st) {
	// 큐 설정
	queue<Pos> q;
	q.push(st);
	// 시작지점은 연료가 0;
	fuel[st.y][st.x] = 0;

	while (!q.empty()) {
		// 현재 지점
		Pos now = q.front();
		q.pop();

		// 4방향 탐색
		for (int d = 0; d < 4; d++) {
			int ny = now.y + dy[d];
			int nx = now.x + dx[d];

			// 경계 체크
			if (ny >= N || ny < 0 || nx >= N || nx < 0) continue;

			// 다음 경로 비용 체크
			int next_cost;
			// 내리막길인 경우
			if (board[now.y][now.x] > board[ny][nx]) {
				next_cost = 0;
			}
			// 오르막길인 경우
			else if (board[now.y][now.x] < board[ny][nx]) {
				next_cost = (board[ny][nx]- board[now.y][now.x]) * 2;
			}
			// 평지인 경우
			else if (board[now.y][now.x] == board[ny][nx]) {
				next_cost = 1;
			}

			// 만약 다음 이동하는 연료 소비가, 기존의 소비보다 클 경우 pass
			if (fuel[ny][nx] <= fuel[now.y][now.x] + next_cost) continue;

			// 연료 맵을 업데이트
			fuel[ny][nx] = fuel[now.y][now.x] + next_cost;

			// 큐에 다음 목적지를 push
			q.push({ ny, nx });
		}
	}
}

// 풀이 함수
void solve() {
	
	bfs(st);

	ans = fuel[N - 1][N - 1];
}


int main() {
	int T;
	cin >> T;
	for (int t = 1; t <= T; t++) {
		init();
		input();
		solve();

		cout << '#' << t << ' ' << ans << endl;
	}
	return 0;
}
```
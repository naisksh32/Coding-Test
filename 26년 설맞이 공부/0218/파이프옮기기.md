# 파이프옮기기
##### Tag: 구현, DFS, 그래프 탐색
##### 풀이 일자: 2026년 2월 18일

## 문제 탐색하기
파이프를 가로, 세로, 대각선으로 배치 시 도달할 수 있는 경우를 계산

### 해결요소
1. 파이프는 가로, 세로, 좌상우하 방향 대각선 파이프로만 구성
2. 가로방향의 파이프가 있을 때에는 가로, 대각선 방향의 파이프만 연결
3. 세로방향의 파이프가 있을 때에는 세로, 대각선 방향의 파이프만 연결
4. 대각선방향의 파이프는 가로, 세로, 대각선 방향의 파이프 연결
5. 0은 빈칸, 1은 벽으로 막혀있음
6. 처음에는 가로 파이프가 기본적으로 주어짐
7. 최종적으로 (N, N)에 도달할 수 있는 파이프 배열의 경우의 수는?

## 코드 설계하기
```
// DFS에 현재 탐색 위치랑, 파이프를 넘겨줘서 계속 탐색 진행
void DFS(Pos now, int pipe) {
	// 기저
	// 만약 현재 좌표가 목표 지점인 (N, N)에 도달 했다면
	// 경우를 1 증가하고 함수를 종료
	if (now.y == N && now.x == N) {
		cnt++;

		return;
	}

	// 재귀
	for (int p = 0; p < 3; p++) {
		// 다음방향 좌표 변수
		int ny, nx;

		// 가로 방향 파이프에서 연결 하려면
		if (pipe == 0) {
			// 가로-가로 연결
			if (p == 0) {
				ny = now.y;
				nx = now.x + 1;
			}
			// 가로-대각선 연결
			else if (p == 1) {
				ny = now.y + 1;
				nx = now.x + 1;

				if (board[ny - 1][nx] != 0) continue;
				if (board[ny][nx - 1] != 0) continue;
			}
			// 만약 가로-세로 연결이면 pass
			else if (p == 2) continue;
		}
		// 대각선 방향 파이프에서 연결 하려면
		else if (pipe == 1) {
			// 대각선-가로 연결
			if (p == 0) {
				ny = now.y;
				nx = now.x + 1;
			}
			// 대각선-대각선 연결
			else if (p == 1) {
				ny = now.y + 1;
				nx = now.x + 1;

				if (board[ny - 1][nx] != 0) continue;
				if (board[ny][nx - 1] != 0) continue;
			}
			// 대각선-세로 연결
			else if (p == 2) {
				ny = now.y + 1;
				nx = now.x;
			}
		}
		// 세로 방향 파이프에서 연결하려면
		else if (pipe == 2) {
			// 만약 세로-가로 연결이면 pass
			if (p == 0) continue;
			// 세로-대각선 연결
			else if (p == 1) {
				ny = now.y + 1;
				nx = now.x + 1;

				if (board[ny - 1][nx] != 0) continue;
				if (board[ny][nx - 1] != 0) continue;
			}
			// 세로-세로 연결
			else if (p == 2) {
				ny = now.y + 1;
				nx = now.x;
			}
		}

		if (ny >= N + 1 || ny < 1 || nx >= N + 1 || nx < 1) continue;
		if (board[ny][nx] == 1) continue;

		board[ny][nx] = 1;
		DFS({ ny, nx }, p);
		board[ny][nx] = 0;
	}
}
```

### 시간 복잡도
O(3^(2N))  
3개의 파이프 경우 x 파이프는 N~2N까지 놓을 수 있음  
N은 최대 16이므로 3^(2*16) ~ 63,413 < 1억 이므로 DFS로 연산 가능  

만약 N이 커지면, Memorization으로 N^2의 시간복잡도를 가지게 만들어서 연산 가능

## 정답 코드
```
#include <iostream>
#include <cstring>
using namespace std;

int ans;
int N;
int board[20][20];	// N은 3~16

int cnt = 0;

struct Pos {
	int y, x;
};

// 파이프 모양 = { 가로, 대각선, 세로 }
int pipe[3] = { 0, 1, 2 };

void init() {
	ans = 0; N = 0; cnt = 0;
	memset(board, -1, sizeof(board));
}
void input() {
	cin >> N;
	for (int i = 1; i <= N; i++) {
		for (int j = 1; j <= N; j++) {
			cin >> board[i][j];
		}
	}
}

void DFS(Pos now, int pipe) {
	// 기저
	// 만약 현재 좌표가 목표 지점인 (N, N)에 도달 했다면
	// 경우를 1 증가하고 함수를 종료
	if (now.y == N && now.x == N) {
		cnt++;

		return;
	}

	// 재귀
	for (int p = 0; p < 3; p++) {
		// 다음방향 좌표 변수
		int ny, nx;

		// 가로 방향 파이프에서 연결 하려면
		if (pipe == 0) {
			// 가로-가로 연결
			if (p == 0) {
				ny = now.y;
				nx = now.x + 1;
			}
			// 가로-대각선 연결
			else if (p == 1) {
				ny = now.y + 1;
				nx = now.x + 1;

				if (board[ny - 1][nx] != 0) continue;
				if (board[ny][nx - 1] != 0) continue;
			}
			// 만약 가로-세로 연결이면 pass
			else if (p == 2) continue;
		}
		// 대각선 방향 파이프에서 연결 하려면
		else if (pipe == 1) {
			// 대각선-가로 연결
			if (p == 0) {
				ny = now.y;
				nx = now.x + 1;
			}
			// 대각선-대각선 연결
			else if (p == 1) {
				ny = now.y + 1;
				nx = now.x + 1;

				if (board[ny - 1][nx] != 0) continue;
				if (board[ny][nx - 1] != 0) continue;
			}
			// 대각선-세로 연결
			else if (p == 2) {
				ny = now.y + 1;
				nx = now.x;
			}
		}
		// 세로 방향 파이프에서 연결하려면
		else if (pipe == 2) {
			// 만약 세로-가로 연결이면 pass
			if (p == 0) continue;
			// 세로-대각선 연결
			else if (p == 1) {
				ny = now.y + 1;
				nx = now.x + 1;

				if (board[ny - 1][nx] != 0) continue;
				if (board[ny][nx - 1] != 0) continue;
			}
			// 세로-세로 연결
			else if (p == 2) {
				ny = now.y + 1;
				nx = now.x;
			}
		}

		if (ny >= N + 1 || ny < 1 || nx >= N + 1 || nx < 1) continue;
		if (board[ny][nx] == 1) continue;

		board[ny][nx] = 1;
		DFS({ ny, nx }, p);
		board[ny][nx] = 0;
	}
}

void solve() {
	int first_pipe = pipe[0];
	board[1][1] = 1;
	board[1][2] = 1;

	DFS({1, 2}, first_pipe);

	ans = cnt;
}


int main() {
	int T;
	cin >> T;
	for (int t = 1; t <= T; t++) {
		init();
		input();
		solve();

		cout << '#' << t << ' ' << ans << endl;
	}
	return 0;
}

```
# 택배 상자 찾기
##### 난이도: ***LV. 1***
##### Link: https://school.programmers.co.kr/learn/courses/30/lessons/389478
##### Tag:  이중 리스트
##### 풀이 일자: 2025년 9월 1일
***
## 문제 탐색하기

![배치1](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e06b4c0d-0ce6-4a2d-8ad4-ba20f9398145/ex1-1.png)
다음 그림처럼 상자가 배열 될 때, 특정 번호의 상자를 꺼내기 위해선 몇개의 상자를 만져야 할까?

### 해결요소
1. 상자의 배열을 이중리스트로 구현한다.
2. 해당 리스트에서 상자를 꺼내기 위한 갯수를 count 한다.
***
## 코드 설계하기
```
arr = []    # 상자들을 담을 빈 리스트

# 행의 갯수(h=n//w+1)만큼 반복
for i in range(n//w+1):

    if i%2 == 0:    # 홀수 행일 때,
        a = [w*i+j for j in range(1, w+1)]      # 열갯수x행번호 + (1,2,3,4~)

    else:           # 짝수 행일 때
        a = [w*i+j for j in range(w, 0, -1)]    # 열갯수x행번호 + (~4,3,2,1)
    
    arr.append(a)   # 상자 리스트에 추가
---------------------------------------------------------------------
# 이중 리스트를 순회 하면서 특정 숫자(num)의 인덱스(x, y)를 결정
for i in range(n//w+1):
    for j in range(w):
        if arr[i][j] == num:
            x, y = i, j
            break
---------------------------------------------------------------------
# num의 열을 기준으로 낮은 행부터 천천히 올라가면서 만지는 상자의 갯수 세기
for i in range(x, n//w+1):
    if arr[i][y] <= n:
        answer += 1
```
### ★★★시간 복잡도★★★
O(n**2) : 이중 리스트를 탐색하면서 2번 탐색해야 함으로
***
## 시도 회차 수정사항
- 특정 조건들을 바로바로 반영하여, 박스 배열을 만들때나, 특정 위치를 찾거나, 다뤄야 하는 상자의 갯수를 빠르게 파악 가능
- 이중 리스트를 구현하지 않고, 수식적으로도 상자의 갯수를 구할 수 있다.
***
## 정답 코드
```
def solution(n, w, num):
    # 1. hxw 배열 형성
    boxes = []      # 박스를 담을 배열
    h = (n//w) + 1  # 행의 갯수
    box_num = 1     # 상자 번호
    
    # 박스 이중 리스트 만들기
    # ---------------------------------------
    # 행, 열별로 반복
    for i in range(h):
        box_line = []   # 한 줄의 박스 정보를 담을 리스트
        
        # 한 행 내부 로직 ---------------------------
        for j in range(w):
            # 박스 번호 부여하는 로직
            if box_num <= n:    # 주어진 박스 번호보다 작으면 1씩 늘려가며 추가
                box_line.append(box_num)
                box_num += 1
            else:               # 박스 번호를 넘어가면 넣지 않고 pass
                pass
        # 한 행 내부 로직 ---------------------------
        
        # 행마다 오름차순, 내림차순 번갈아 가면서 정렬
        box_line.sort(reverse=i%2)
        
        # 마지막 행에 대해서
        if len(box_line) != w:
            if i%2 == 0:  # 홀수 열일 때
                while len(box_line) != w:
                    box_line.append(0)      # 0을 뒤에다 추가

            else:         # 짝수 열일 때
                while len(box_line) != w:
                    box_line.insert(0, 0)   # 0을 앞에다 추가
        
        boxes.append(box_line)
    # ---------------------------------------

    for i in range(len(boxes)):
        if num in boxes[i]:
            print("행", i, "열", boxes[i].index(num))
            row = i
            column = boxes[i].index(num)
    
    target = []
    for _ in range(h):
        target.append(boxes[_][column])
    
    target.sort(reverse=True)

    answer = target.index(num) +1
    return answer
```